/*
 * Camera.h
 *
 *  Created on: Mar 21, 2018
 *      Author: cryog
 */

#ifndef SRC_MODULES_CAMERA_H_
#define SRC_MODULES_CAMERA_H_


class CameraModule : public Module{
private:
	//
public:
	static void VisionThread()
    {
        CameraServer::GetInstance()->SetSize(CameraServer::kSize320x240);
        cs::UsbCamera camera = CameraServer::GetInstance()->StartAutomaticCapture();
        cs::CvSink cvSink = CameraServer::GetInstance()->GetVideo();
        cs::CvSource outputStreamStd = CameraServer::GetInstance()->PutVideo("Tracking", 320, 240);
        cv::Mat source;
        cv::Mat output;
        while(true) {
            if(cvSink.GrabFrame(source) == 0) continue;
            SmartDashboard::PutNumber("Source Rows", source.rows);
            SmartDashboard::PutNumber("Source Cols", source.cols);
            cv::Mat tmp1;
            cv::Mat tmp2;

            //cv::Mat tmpYellowL(320, 240, )
            cv::Canny(source, tmp1, 20, 200, 3, true);
            SmartDashboard::PutNumber("Canny Rows", tmp1.rows);
            SmartDashboard::PutNumber("Canny Cols", tmp1.cols);
            cv::Vec3b * currentRowS;
            for (int j = 0; j < source.rows; ++j)
                {
                    currentRowS = source.ptr<cv::Vec3b>(j);
                    for (int i = 0; i < source.cols; ++i)
                    {
                        currentRowS[i][2] = tmp1.at<uchar>(j, i) != 0 ? 255 : currentRowS[i][2];
                    }
                }
            outputStreamStd.PutFrame(source);
        }
    }
    void ModuleInit()
    {
        std::thread visionThread(VisionThread);
        visionThread.detach();
    }
};


#endif /* SRC_MODULES_CAMERA_H_ */
